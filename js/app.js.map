{"version":3,"sources":["app/js/initialize.js","app/js/debounce_throttle.js","app/js/inview.js","app/js/mobile-menu.js","app/js/scroll-to.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/js/app.js","sourcesContent":["// Trigger functions when the initial HTML document\n// has been completely loaded and parsed,\n// without waiting for stylesheets, images, and\n// subframes to finish loading\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Mobile menu interactions\n    var landingMobileMenu = new Mobile_Menu();\n    landingMobileMenu.init();\n\n    // Scroll to on click interactions\n    var clickScroll = new Scroll_To();\n    clickScroll.init();\n\n    setFullYearText();\n});\n\n\n// Trigger functions after page is completely loaded\nwindow.onload = function() {\n    // Do something, remove preloader perhaps\n    // console.log(\"Page fully loaded.\");\n    // console.log(\"Initialize.js\");\n\n    // Load animation\n    document.getElementById('header-nav').classList.add('animate');\n    document.getElementById('hero-info').classList.add('animate');\n    document.getElementById('hero-image').classList.add('animate');\n\n\n    // General inview animation, linked with \"Cascading\" system\n    var inviewObjects = document.getElementsByClassName('motion-cascade');\n\n    // Cascade animation timing values\n    for (var i = 0; i < inviewObjects.length; i++) {\n        var inview = InView(inviewObjects[i], function(isInView, data) {\n            if ((this.el.getBoundingClientRect().top - window.innerHeight) < 0) {\n                this.el.classList.add('animate');\n\n            } else {\n                this.el.classList.remove('animate');\n            }\n        })\n    }\n\n    setupAutoSliderCarousel();\n}\n\nfunction setFullYearText() {\n    let elems = document.getElementsByClassName('datetime__year');\n\n    for (var i = 0; i < elems.length; i++) {\n        elems[i].textContent = new Date().getFullYear();\n    }\n}\n\nfunction setupAutoSliderCarousel() {\n    var slider = document.querySelector('.img-carousel ._inner-wrapper');\n    var reviewItems = document.querySelectorAll('.img-carousel ._img-container');\n    var progressContainer = document.querySelector('.img-carousel ._pagination');\n    var progressIndicators = document.querySelectorAll('._pagination ._indicator');\n    var timerId = null;\n\n    // let currentSlide = 0;\n\n    function setSlide(num) {\n        var current = Number(progressContainer.getAttribute('data-selected'));\n        var selected = Number(num);\n        \n        var distanceToSlide = slider.clientWidth * selected * -1;\n\n        // console.log(currentSlide, selected)\n\n        // if (current > selected) {\n        //     // distanceToSlide *= -1;\n\n        //     console.log('current more than selected')\n        // }\n\n\n\n        // console.log(distanceToSlide)\n\n\n        // slider.style.transform = `translateX(${distanceToSlide}px)`;\n\n        slider.style.left = `${distanceToSlide}px`;\n\n\n        // console.log('set', Number(num));\n\n        // Set the current number the slide is now on\n        progressContainer.setAttribute('data-selected', selected);\n        // currentSlide = selected;\n\n        // Show indicators as bubbles\n        setProgress(num);\n    }\n\n    function setProgress(num) {\n        for (let i = 0; i < progressIndicators.length; i++) {\n            if (Number(num) === Number(i)) {\n                progressIndicators[i].classList.add('active');\n            }\n                else {\n                    progressIndicators[i].classList.remove('active');        \n                }\n        }\n    }\n\n    function startAutoSlide() {\n        timerId = setInterval(() => {\n            let current = Number(progressContainer.getAttribute('data-selected'));\n            let slideNext = (current + 1) % reviewItems.length;\n            setSlide(slideNext);\n        }, 6000); \n    }\n\n    for (let i = 0; i < progressIndicators.length; i++) {\n        progressIndicators[i].addEventListener('click', function(e) {\n            clearInterval(timerId);\n            setSlide(i);\n            startAutoSlide();\n        }.bind(this));\n    }\n\n    // Slide the cards every x interval\n    startAutoSlide()\n    \n}\n","function throttle(fn, minDelay, scope) {\n    var lastCall = 0;\n    return function() {\n        var now = +new Date();\n        if (now - lastCall < minDelay) {\n            return;\n        }\n        lastCall = now;\n        fn.apply(scope, arguments);\n    };\n}\n\nfunction debounce(func, wait, immediate) {\n\tvar timeout;\n\treturn function() {\n\t\tvar context = this, args = arguments;\n\t\tvar later = function() {\n\t\t\ttimeout = null;\n\t\t\tif (!immediate) func.apply(context, args);\n\t\t};\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t\tif (callNow) func.apply(context, args);\n\t};\n};",";(function (root) {\n  function throttle (fn, threshhold, scope) {\n    threshhold || (threshhold = 100)\n    var last,\n      deferTimer\n\n    return function () {\n      var context = scope || this\n\n      var now = +(new Date())\n\n      var args = arguments\n      if (last && now < last + threshhold) {\n        clearTimeout(deferTimer)\n        deferTimer = setTimeout(function () {\n          last = now\n          fn.apply(context, args)\n        }, threshhold)\n      } else {\n        last = now\n        fn.apply(context, args)\n      }\n    }\n  }\n\n  function hasClass (el, name) {\n    return new RegExp(' ' + name + ' ').test(' ' + el.className + ' ')\n  }\n\n  function addClass (el, name) {\n    if (!hasClass(el, name)) {\n      el.className += ' ' + name\n    }\n    return el\n  }\n\n  function removeClass (el, name) {\n    var newClass = ' ' + el.className.replace(/[\\t\\r\\n]/g, ' ') + ' '\n    if (hasClass(el, name)) {\n      while (newClass.indexOf(' ' + name + ' ') >= 0) {\n        newClass = newClass.replace(' ' + name + ' ', ' ')\n      }\n      el.className = newClass.replace(/^\\s+|\\s+$/g, '')\n    }\n    return el\n  }\n\n  function removeEvent (el, name, fn) {\n    if (el.removeEventListener) {\n      return el.removeEventListener(name, fn)\n    } else if (el.detachEvent) {\n      return el.detachEvent('on' + name, fn)\n    }\n  }\n\n  function addEvent (el, name, fn) {\n    if (el.addEventListener) {\n      return el.addEventListener(name, fn, false)\n    } else if (el.attachEvent) {\n      return el.attachEvent('on' + name, fn)\n    }\n  }\n\n  function getScrollTop () {\n    if (typeof window.pageYOffset !== 'undefined') {\n      return window.pageYOffset\n    } else {\n      var b = document.body\n      var d = document.documentElement\n      d = d.clientHeight ? d : b\n      return d.scrollTop\n    }\n  }\n\n  function isInView (obj) {\n    var winTop = getScrollTop()\n\n    var winBottom = winTop + window.innerHeight\n\n    var objTop = obj.getBoundingClientRect().top + document.documentElement.scrollTop\n\n    var objBottom = objTop + obj.offsetHeight\n\n    var offset = 0\n\n    if ((objTop <= winBottom + offset) && (objBottom >= winTop)) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * @desc Create an InView instance.\n   *\n   * @class\n   * @func InView\n   * @param {HTMLElement} element - element to detect when scrolled to view\n   * @param {scrollCallback} scrollCallback - callback function fired on scroll event\n   * @return {HTMLElement} - element\n   *\n   * @example\n   * var el = document.querySelector('.item');\n   *\n   * var InView = InView(el, function(isInView, data) {\n   *   if (isInView) {\n   *     console.log('in view');\n   *   } else {\n   *     if (data.windowScrollTop - (data.elementOffsetTop - data.inViewHeight) > data.inViewHeight) {\n   *       console.log('not in view (scroll up)');\n   *     } else {\n   *       console.log('not in view (scroll down)');\n   *     }\n   *   }\n   * });\n   */\n  function InView (el, callback) {\n    var _this = this\n    if (!(_this instanceof InView)) {\n      return new InView(el, callback)\n    }\n\n    _this.el = el\n    _this.callback = callback.bind(_this)\n    _this.destroy = function () {}\n\n    if (!el) {\n      return _this\n    }\n\n    var isDestroyed = false\n\n    var check = function check (e) {\n      if (isDestroyed) return false\n\n      var params = {\n        windowScrollTop: getScrollTop(),\n        elementOffsetTop: _this.el.offsetTop,\n        inViewHeight: window.innerHeight,\n        elementOffsetTopInViewHeight: window.innerHeight - (getScrollTop() - (_this.el.offsetTop - window.innerHeight))\n      }\n      if (isInView(_this.el)) {\n        addClass(_this.el, 'inview')\n        _this.callback.call(_this, true, params)\n      } else {\n        removeClass(_this.el, 'inview')\n        _this.callback.call(_this, false, params)\n      }\n    }\n\n    var throttledCheck = throttle(check, 100)\n\n    addEvent(window, 'scroll', throttledCheck)\n\n    _this.destroy = function () {\n      isDestroyed = true\n      removeEvent(window, 'scroll', throttledCheck)\n    }\n\n    throttledCheck()\n\n    return _this\n  }\n\n  /**\n   * @desc InView callback\n   *\n   * @callback scrollCallback\n   * @param {boolean} isInView - is in view\n   * @param {object} data - scroll data\n   * @param {number} data.windowScrollTop - scrolled amount\n   * @param {number} data.elementOffsetTop - element top offset\n   * @param {number} data.inViewHeight - height of visible area\n   * @param {number} data.elementOffsetTopInViewHeight - element top offset relative to height of visible area\n   */\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = InView\n    }\n    exports.InView = InView\n  } else {\n    root.InView = InView\n  }\n})(window);","var Mobile_Menu = function() {\n\tvar _self = this;\n\n\tthis.opened = false;\n\tthis.initScrollPosition = 0;\n\tthis.pageScroll = document.body;\n\tthis.transitionDuration = 900; // in ms\n\n\tthis.trigger = document.getElementById('mobile-menu-trigger');\n\tthis.container = document.getElementById('mobile-menu');\n\tthis.pageNavs = document.getElementsByClassName('mob-menu-page-scroll');\n\n\n\tthis.init = function() {\n\t\tthis.addListeners();\n\t}\n\n\tthis.addListeners = function() {\n\t\tthis.trigger.addEventListener('click', function() {\n\t\t\tif (!_self.opened) {\n\t\t\t\t_self.openIt();\n\n\t\t\t} else {\n\t\t\t\t_self.closeIt();\n\t\t\t\twindow.scrollTo(0, _self.initScrollPosition);\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0; i < _self.pageNavs.length; i++) {\n\t\t\t_self.pageNavs[i].addEventListener('click', function() {\n\t\t\t\t_self.closeIt();\n\t\t\t});\n\t\t}\n\t}\n\n\tthis.openIt = function() {\n\t\tthis.trigger.classList.add('opened');\n\t\tthis.container.classList.add('opened');\n\n\t\tthis.initScrollPosition = window.pageYOffset;\n\n\t\tthis.opened = true;\n\t}\n\tthis.closeIt = function() {\n\t\tthis.trigger.classList.remove('opened');\n\t\tthis.container.classList.remove('opened');\n\n\n\t\tthis.opened = false;\n\t}\n}","var Scroll_To = function() {\n\tvar _self = this;\n\n\tthis.cof = 0.05;\n\n\tthis.currentPosition = 0;\n\tthis.displacement = 0;\n\tthis.newPosition = 0;\n\n\tthis.intervalSpeed = 10;\n\tthis.scrollInterval;\n\tthis.scrollTarget;\n\tthis.scrollSpeed = 0;\n\tthis.interpolatedScrollPosition = 0;\n\n\tthis.triggers = document.getElementsByClassName('scroll-to-js');\n\n\tthis.init = function() {\n\t\tthis.addListeners();\n\t}\n\n\tthis.addListeners = function() {\n\t\tfor (var i = 0; i < _self.triggers.length; i++) {\n\t\t\t_self.triggers[i].addEventListener('click', function(e) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\tvar _domElementId = e.target.getAttribute('href')\n\t\t\t\tvar _target = document.getElementById(_domElementId);\n\n\t\t\t\t_self.initInterval(_target);\n\t\t\t});\n\t\t}\n\n\t\t// Regain control if user scrolls after click\n\t\twindow.addEventListener('wheel', throttle(_self.stopInterval, 120));\n\t\twindow.addEventListener('touchstart', _self.stopInterval, false);\n\t}\n\n\tthis.getCurrentPosition = function() {\n\t\t_self.currentPosition = window.pageYOffset;\n\t}\n\n\tthis.getDisplacement = function(target) {\n\t\t_self.displacement = target.getBoundingClientRect().y;\n\t}\n\n\tthis.getNewPosition = function() {\n\t\t_self.newPosition = _self.currentPosition + _self.displacement;\n\t}\n\n\tthis.goTo = function(target) {\n\t\t// console.log(target);\n\n\t\tinviewTriggerInSmoothScroll = true;\n\n\t\t_self.getCurrentPosition();\n\t\t_self.getDisplacement(target);\n\t\t_self.getNewPosition();\n\n\t\twindow.scroll(0, _self.newPosition);\n\t}\n\n\tthis.getTo = function() {\n\t\t_self.getCurrentPosition();\n\t\t_self.getDisplacement(_self.scrollTarget);\n\t\t_self.getNewPosition();\n\t\t// console.log(\"_self.currentPosition: \" + _self.currentPosition + \". _self.displacement: \" + _self.displacement + \". _self.newPosition: \" + _self.newPosition);\n\t\t// console.log(\"_self.newPosition: \" + _self.newPosition);\n\n\t\t_self.interpolatedScrollPosition = _self.currentPosition;\n\t\t_self.scrollSpeed = (_self.newPosition - _self.currentPosition ) * _self.cof;\n\t\tif ( Math.abs(_self.scrollSpeed) < 1 ) _self.scrollSpeed = _self.scrollSpeed / Math.abs(_self.scrollSpeed);\n\n\n\t\t_self.interpolatedScrollPosition += _self.scrollSpeed;\n\t\t// console.log('speed: ' + _self.scrollSpeed);\n\t\t// console.log('displacement: ' + _self.displacement);\n\n\n\t\tif (_self.displacement < 5 && _self.displacement > -5) {\n\t\t\t_self.stopInterval();\n\t\t\t// console.log(\"threshold reached, interval stopped\");\n\n\t\t}\n\n\n\t\twindow.scroll(0, _self.interpolatedScrollPosition);\n\t}\n\n\n\tthis.initInterval = function(target) {\n\t\t// console.log('init interval');\n\t\t_self.scrollTarget = target;\n\t\t_self.stopInterval();\n\t\t_self.scrollInterval = setInterval(_self.getTo, _self.intervalSpeed);\n\t}\n\n\tthis.stopInterval = function() {\n\t\tclearInterval(_self.scrollInterval);\n\t\t// console.log('stopped interval')\n\t}\n}"]}